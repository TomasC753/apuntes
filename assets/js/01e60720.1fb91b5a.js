"use strict";(self.webpackChunkapuntes_dart=self.webpackChunkapuntes_dart||[]).push([[6142],{7560:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var o=n(5893),r=n(1151);const s={sidebar_label:"Introducci\xf3n a Programaci\xf3n Orientada a Objetos (POO)",sidebar_position:1},i="Introducci\xf3n a Programaci\xf3n Orientada a Objetos (POO)",c={id:"paradigmas-de-programacion/programacion-orientada-a-objetos/introduccion-a-programacion-orientada-a-objetos",title:"Introducci\xf3n a Programaci\xf3n Orientada a Objetos (POO)",description:"La programaci\xf3n Orientada a objetos se define como un paradigma de la programaci\xf3n, una manera de programar espec\xedfica, donde se organiza el c\xf3digo en unidades denominadas clases, de las cuales se crean objetos que se relacionan entre s\xed para conseguir los objetivos de las aplicaciones.",source:"@site/docs/paradigmas-de-programacion/programacion-orientada-a-objetos/introduccion-a-programacion-orientada-a-objetos.md",sourceDirName:"paradigmas-de-programacion/programacion-orientada-a-objetos",slug:"/paradigmas-de-programacion/programacion-orientada-a-objetos/introduccion-a-programacion-orientada-a-objetos",permalink:"/apuntes/docs/paradigmas-de-programacion/programacion-orientada-a-objetos/introduccion-a-programacion-orientada-a-objetos",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_label:"Introducci\xf3n a Programaci\xf3n Orientada a Objetos (POO)",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Programaci\xf3n Orientada a Objetos (POO)",permalink:"/apuntes/docs/category/programaci\xf3n-orientada-a-objetos-poo"},next:{title:"Programaci\xf3n orientada a objetos en Dart",permalink:"/apuntes/docs/paradigmas-de-programacion/programacion-orientada-a-objetos/poo-en-dart"}},d={},l=[{value:"Motivaci\xf3n de la programaci\xf3n orientada a objetos",id:"motivaci\xf3n-de-la-programaci\xf3n-orientada-a-objetos",level:2},{value:"Principios Fundamentales",id:"principios-fundamentales",level:2},{value:"Clases y objetos:",id:"clases-y-objetos",level:3},{value:"Conceptos Clave:",id:"conceptos-clave",level:3},{value:"Atributos:",id:"atributos",level:4},{value:"M\xe9todos:",id:"m\xe9todos",level:4},{value:"Constructores:",id:"constructores",level:4},{value:"Abstracci\xf3n",id:"abstracci\xf3n",level:3},{value:"Encapsulaci\xf3n:",id:"encapsulaci\xf3n",level:3},{value:"Herencia:",id:"herencia",level:3},{value:"Polimorfismo:",id:"polimorfismo",level:3}];function t(e){const a={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(a.h1,{id:"introducci\xf3n-a-programaci\xf3n-orientada-a-objetos-poo",children:"Introducci\xf3n a Programaci\xf3n Orientada a Objetos (POO)"}),"\n",(0,o.jsx)(a.p,{children:"La programaci\xf3n Orientada a objetos se define como un paradigma de la programaci\xf3n, una manera de programar espec\xedfica, donde se organiza el c\xf3digo en unidades denominadas clases, de las cuales se crean objetos que se relacionan entre s\xed para conseguir los objetivos de las aplicaciones."}),"\n",(0,o.jsx)(a.p,{children:"Podemos entender la programaci\xf3n Orientada a objetos (POO) como una forma especial de programar, m\xe1s cercana a como expresar\xedamos las cosas en la vida real que otros tipos de programaci\xf3n, que permite dise\xf1ar mejor las aplicaciones, llegando a mayores cotas de complejidad, sin que el c\xf3digo se vuelva inmanejable."}),"\n",(0,o.jsx)(a.h2,{id:"motivaci\xf3n-de-la-programaci\xf3n-orientada-a-objetos",children:"Motivaci\xf3n de la programaci\xf3n orientada a objetos"}),"\n",(0,o.jsx)(a.p,{children:"Durante a\xf1os, los programadores se han dedicado a construir aplicaciones muy parecidas que resolv\xedan una y otra vez los mismos problemas. Para conseguir que los esfuerzos de los programadores puedan ser reutilizados se cre\xf3 la posibilidad de utilizar m\xf3dulos. El primer m\xf3dulo existente fue la funci\xf3n, que somos capaces de escribir una vez e invocar cualquier n\xfamero de veces."}),"\n",(0,o.jsx)(a.p,{children:"Sin embargo, la funci\xf3n se centra mucho en aportar una funcionalidad dada, pero no tiene tanto inter\xe9s con los datos. Es cierto que la funci\xf3n puede recibir datos como par\xe1metros y puede devolverlos, pero los trata de una estructura muy vol\xe1til, centrada en las operaciones. Simplemente hace su trabajo, procesando los par\xe1metros recibidos y devuelve una respuesta."}),"\n",(0,o.jsx)(a.p,{children:"En las aplicaciones en realidad los datos est\xe1n muy ligados a la funcionalidad. Por ejemplo podemos imaginar un punto que se mueve por la pantalla. El punto tiene unas coordenadas y podemos trasladarlo de una posici\xf3n a otra, sumando o restando valores a sus coordenadas. Antes de la programaci\xf3n orientada a objetos ocurr\xeda que cada coordenada del punto ten\xeda que guardarse en una variable diferente (dos variables para ser exacto: x, y) y las funciones de traslaci\xf3n estaban almacenadas por otra parte. Esta situaci\xf3n no facilitaba la organizaci\xf3n del c\xf3digo ni tampoco su reutilizaci\xf3n."}),"\n",(0,o.jsx)(a.p,{children:"Con la Programaci\xf3n Orientada a Objetos se buscaba resolver estas situaciones, creando unas mejores condiciones para poder desarrollar aplicaciones cada vez m\xe1s complejas, sin que el c\xf3digo se volviera un caos. Adem\xe1s, se pretend\xeda dar una de pautas para realizar las cosas de manera que otras personas puedan utilizarlas y adelantar su trabajo, lo que deriva en mayores facilidades para la reutilizaci\xf3n del c\xf3digo."}),"\n",(0,o.jsx)(a.h2,{id:"principios-fundamentales",children:"Principios Fundamentales"}),"\n",(0,o.jsx)(a.h3,{id:"clases-y-objetos",children:"Clases y objetos:"}),"\n",(0,o.jsxs)(a.ul,{children:["\n",(0,o.jsx)(a.li,{children:"Una clase es una plantilla que define la estructura y el comportamiento de un objeto."}),"\n",(0,o.jsx)(a.li,{children:"Un objeto es una instancia de una clase, con datos espec\xedficos y la capacidad de realizar operaciones definidas por la clase."}),"\n"]}),"\n",(0,o.jsx)(a.p,{children:"Se puede pensar una clase como un plano para construir casas. El plano especifica c\xf3mo se deben construir las casas, qu\xe9 habitaciones tendr\xe1n, y c\xf3mo estar\xe1n conectadas. Cada casa construida seg\xfan ese plano ser\xeda un objeto."}),"\n",(0,o.jsx)(a.p,{children:(0,o.jsx)(a.img,{src:"https://miro.medium.com/v2/resize:fit:828/format:webp/1*d2crhvTjaWQzEyeF7GEElA.png",alt:""})}),"\n",(0,o.jsxs)(a.ul,{children:["\n",(0,o.jsx)(a.li,{children:"Cuando construimos una casa el arquitecto dise\xf1a los planos (blueprints) que definen c\xf3mo debe ser construida la casa. A esta plantilla, en programaci\xf3n se la conocemos como clase."}),"\n",(0,o.jsx)(a.li,{children:"A una casa construida a partir de la plantilla se la conoce como instancia de la clase."}),"\n"]}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-dart",children:'class Auto {\r\n    // Propiedades\r\n    String marca;\r\n    String modelo;\r\n    double velocidad;\r\n\r\n    // Constructor\r\n    Auto({\r\n        required this.marca,\r\n        required this.modelo,\r\n        this.velocidad = 0 \r\n    });\r\n\r\n    void acelerar(int incremento) {\r\n        velocidad += incremento;\r\n    }\r\n\r\n    void frenar(int decremento) {\r\n        velocidad -= decremento;\r\n    }\r\n}\r\n\r\n// Creaci\xf3n de objetos (instancias) de la clase Auto\r\nvoid main() {\r\n    Auto auto1 = Auto(marca: "Toyota", modelo: "Corolla");\r\n    Auto auto2 = Auto(marca: "volkswagen", modelo: "Suran My2019")\r\n}\n'})}),"\n",(0,o.jsxs)(a.p,{children:["En este ejemplo, ",(0,o.jsx)(a.code,{children:"Auto"})," es la clase que define la estructura y comportamiento de los autos. ",(0,o.jsx)(a.code,{children:"auto1"})," y ",(0,o.jsx)(a.code,{children:"auto2"})," son objetos (instancias) de esa clase, cada uno con sus propios datos (marca, modelo, velocidad) y capaces de realizar las operaciones definidas en la clase (acelerar y frenar)."]}),"\n",(0,o.jsx)(a.h3,{id:"conceptos-clave",children:"Conceptos Clave:"}),"\n",(0,o.jsx)(a.h4,{id:"atributos",children:"Atributos:"}),"\n",(0,o.jsxs)(a.ul,{children:["\n",(0,o.jsx)(a.li,{children:"Son variables que almacenan datos asociados con un objeto."}),"\n",(0,o.jsx)(a.li,{children:"Representan las propiedades de un objeto."}),"\n"]}),"\n",(0,o.jsx)(a.h4,{id:"m\xe9todos",children:"M\xe9todos:"}),"\n",(0,o.jsxs)(a.ul,{children:["\n",(0,o.jsx)(a.li,{children:"Son funciones que definen el comportamiento de un objeto."}),"\n",(0,o.jsx)(a.li,{children:"Realizan operaciones sobre los datos de la clase."}),"\n"]}),"\n",(0,o.jsx)(a.h4,{id:"constructores",children:"Constructores:"}),"\n",(0,o.jsxs)(a.ul,{children:["\n",(0,o.jsx)(a.li,{children:"M\xe9todos especiales llamados al crear un objeto."}),"\n",(0,o.jsx)(a.li,{children:"Inicializan los atributos del objeto."}),"\n"]}),"\n",(0,o.jsx)(a.h3,{id:"abstracci\xf3n",children:"Abstracci\xf3n"}),"\n",(0,o.jsx)(a.p,{children:"La abstracci\xf3n en la programaci\xf3n orientada a objetos (POO) es un concepto fundamental que nos permite simplificar y organizar nuestro c\xf3digo de manera eficiente. En t\xe9rminos simples, la abstracci\xf3n se enfoca en la visi\xf3n externa de un objeto, separando el comportamiento espec\xedfico de un objeto.  Esto se logra mediante la creaci\xf3n de una interfaz que define los m\xe9todos que ser\xe1n implementados por una clase sin necesidad de definir qu\xe9 har\xe1n estos m\xe9todos. La interfaz abarca las responsabilidades de un objeto y establece todas las suposiciones que pueda hacer un objeto cliente acerca del comportamiento de un objeto servidor."}),"\n",(0,o.jsx)(a.p,{children:"En resumen, la abstracci\xf3n es una t\xe9cnica que nos permite definir caracter\xedsticas espec\xedficas de un objeto, aquellas que lo distinguen de los dem\xe1s tipos de objetos y que logran definir l\xedmites conceptuales respecto a quien est\xe1 haciendo dicha abstracci\xf3n del objeto."}),"\n",(0,o.jsx)(a.h3,{id:"encapsulaci\xf3n",children:"Encapsulaci\xf3n:"}),"\n",(0,o.jsxs)(a.ul,{children:["\n",(0,o.jsx)(a.li,{children:"La encapsulaci\xf3n es el principio de ocultar los detalles internos de un objeto y exponer solo lo necesario para su uso."}),"\n",(0,o.jsx)(a.li,{children:"Se logra mediante el uso de modificadores de acceso como p\xfablico, privado y protegido."}),"\n"]}),"\n",(0,o.jsx)(a.h3,{id:"herencia",children:"Herencia:"}),"\n",(0,o.jsxs)(a.ul,{children:["\n",(0,o.jsx)(a.li,{children:"La herencia es un mecanismo que permite crear una nueva clase basada en una clase existente, heredando sus atributos y m\xe9todos."}),"\n",(0,o.jsx)(a.li,{children:"La clase que se hereda se llama clase base o superclase, y la nueva clase se llama clase derivada o subclase."}),"\n",(0,o.jsx)(a.li,{children:"La subclase puede extender o modificar la funcionalidad de la superclase."}),"\n",(0,o.jsx)(a.li,{children:"Favorece la reutilizaci\xf3n del c\xf3digo y la creaci\xf3n de jerarqu\xedas de clases."}),"\n"]}),"\n",(0,o.jsxs)(a.p,{children:["Piensa en una jerarqu\xeda de veh\xedculos. Tienes una clase base llamada ",(0,o.jsx)(a.code,{children:"Vehiculo"})," que tiene propiedades y comportamientos comunes a todos los veh\xedculos. Luego, puedes tener subclases como ",(0,o.jsx)(a.code,{children:"Auto"})," y ",(0,o.jsx)(a.code,{children:"Camion"})," que heredan de la clase base y agregan caracter\xedsticas espec\xedficas."]}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-dart",children:"// SuperClase\r\nclass Vehiculo {\r\n    // Propiedades\r\n    String marca;\r\n    String modelo;\r\n    int velocidad;\r\n    \r\n    // Constructor\r\n    Vehiculo({\r\n        required this.marca,\r\n        required this.modelo,\r\n        this.velocidad = 0\r\n    })\r\n}\r\n\r\n// SubClase\r\nclass Auto extends Vehiculo {\r\n    // Constructor\r\n    Auto({\r\n        required super.marca,\r\n        required super.modelo\r\n    });\r\n}\r\n\r\n// SubClase\r\nclass Camion extends Vehiculo {\r\n    // Propiedades exclusivas de un camion\r\n    String tipoDeCarga;\r\n    List<dynamic> carga;\r\n\r\n    // Constructor\r\n    Camion({\r\n        required this.tipoDeCarga,\r\n        required super.marca,\r\n        required super.modelo\r\n    });\r\n\r\n    // M\xe9todo exclusivo del camion\r\n    void cargar(List<dynamic> cargamento) {\r\n        carga.addAll(cargamento);\r\n    }\r\n}\n"})}),"\n",(0,o.jsxs)(a.p,{children:["En este ejemplo, ",(0,o.jsx)(a.code,{children:"Auto"})," y ",(0,o.jsx)(a.code,{children:"Camion"})," extienden de la clase padre ",(0,o.jsx)(a.code,{children:"Vehiculo"}),", el cual hereda las propiedades ",(0,o.jsx)(a.code,{children:"marca"})," y ",(0,o.jsx)(a.code,{children:"modelo"})," a sus hijos y estos \xfaltimos tienen la posibilidad de desarrollar m\xe9todos y propiedades nuevas como es el caso de la subclase ",(0,o.jsx)(a.code,{children:"Camion"})," que presenta una propiedad ",(0,o.jsx)(a.code,{children:"carga"})," y un m\xe9todo ",(0,o.jsx)(a.code,{children:"cargar"}),"."]}),"\n",(0,o.jsx)(a.h3,{id:"polimorfismo",children:"Polimorfismo:"}),"\n",(0,o.jsxs)(a.ul,{children:["\n",(0,o.jsx)(a.li,{children:"El polimorfismo permite que un objeto se comporte de diferentes maneras seg\xfan el contexto."}),"\n",(0,o.jsxs)(a.li,{children:["Puede manifestarse de dos formas: polimorfismo de sobrecarga y polimorfismo de anulaci\xf3n (override).","\n",(0,o.jsxs)(a.ul,{children:["\n",(0,o.jsx)(a.li,{children:"La sobrecarga implica tener m\xfaltiples m\xe9todos con el mismo nombre pero con diferentes par\xe1metros."}),"\n",(0,o.jsx)(a.li,{children:"La anulaci\xf3n ocurre cuando una subclase redefine un m\xe9todo de la superclase."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(a.p,{children:"Imagina una interfaz de m\xfasica. Puedes reproducir m\xfasica desde un tel\xe9fono, una computadora o un altavoz, pero el comportamiento de reproducci\xf3n es diferente en cada dispositivo. Eso es polimorfismo: la capacidad de realizar la misma acci\xf3n (reproducci\xf3n) de diferentes maneras seg\xfan el dispositivo."}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-dart",metastring:'title="Ejemplo de polimorfismo de anulaci\xf3n"',children:"abstract class Animal {\r\n    void hacerSonido();\r\n}\r\n\r\nclass Perro extends Animal {\r\n    @override\r\n    void hacerSonido() {\r\n        print('\xa1guau guau!');\r\n    }\r\n}\r\n\r\nclass Gato extends Animal {\r\n    @override\r\n    void hacerSonido() {\r\n        print('Dame comida humano!!');\r\n    }\r\n}\r\n\r\nvoid main() {\r\n    Perro perro1 = Perro();\r\n    Gato gato1 = Gato();\r\n\r\n    perro1.hacerSonido(); // Imprime \"\xa1guau guau!\"\r\n    gato1.hacerSonido(); // Imprime \"Dame comida humano!!\"\r\n}\n"})}),"\n",(0,o.jsxs)(a.p,{children:["En este ejemplo se esta diciendo que ",(0,o.jsx)(a.code,{children:"Perro"})," y ",(0,o.jsx)(a.code,{children:"Gato"})," son animales (extienden de la clase ",(0,o.jsx)(a.code,{children:"Animal"}),") y que todos los animales pueden emitir un sonido a traves del m\xe9todo ",(0,o.jsx)(a.code,{children:"hacerSonido"}),", sin embargo, un perro y un gato emiten sonidos diferentes por lo que cada uno su respectiva subclase anula el m\xe9todo original heredado por la clase padre y lo adapta a su contexto."]})]})}function u(e={}){const{wrapper:a}={...(0,r.a)(),...e.components};return a?(0,o.jsx)(a,{...e,children:(0,o.jsx)(t,{...e})}):t(e)}},1151:(e,a,n)=>{n.d(a,{Z:()=>c,a:()=>i});var o=n(7294);const r={},s=o.createContext(r);function i(e){const a=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function c(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:a},e.children)}}}]);